import {
  require_jsx_runtime
} from "./chunk-TBGBCMBH.js";
import {
  __toESM,
  require_react
} from "./chunk-O37TL4HA.js";

// node_modules/@szhsin/react-accordion/dist/esm/components/Accordion.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-transition-state/dist/esm/hooks/useTransitionState.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/react-transition-state/dist/esm/hooks/utils.mjs
var PRE_ENTER = 0;
var ENTERING = 1;
var ENTERED = 2;
var PRE_EXIT = 3;
var EXITING = 4;
var EXITED = 5;
var UNMOUNTED = 6;
var STATUS = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"];
var getState = (status) => ({
  _s: status,
  status: STATUS[status],
  isEnter: status < PRE_EXIT,
  isMounted: status !== UNMOUNTED,
  isResolved: status === ENTERED || status > EXITING
});
var startOrEnd = (unmounted) => unmounted ? UNMOUNTED : EXITED;
var getEndStatus = (status, unmountOnExit) => {
  switch (status) {
    case ENTERING:
    case PRE_ENTER:
      return ENTERED;
    case EXITING:
    case PRE_EXIT:
      return startOrEnd(unmountOnExit);
  }
};
var getTimeout = (timeout) => typeof timeout === "object" ? [timeout.enter, timeout.exit] : [timeout, timeout];
var nextTick = (transitState, status) => setTimeout(() => {
  isNaN(document.body.offsetTop) || transitState(status + 1);
}, 0);

// node_modules/react-transition-state/dist/esm/hooks/useTransitionMap.mjs
var import_react2 = __toESM(require_react(), 1);
var updateState = (key, status, setStateMap, latestStateMap, timeoutId, onChange) => {
  clearTimeout(timeoutId);
  const state = getState(status);
  const stateMap = new Map(latestStateMap.current);
  stateMap.set(key, state);
  setStateMap(stateMap);
  latestStateMap.current = stateMap;
  onChange && onChange({
    key,
    current: state
  });
};
var useTransitionMap = ({
  allowMultiple,
  enter = true,
  exit = true,
  preEnter,
  preExit,
  timeout,
  initialEntered,
  mountOnEnter,
  unmountOnExit,
  onStateChange: onChange
} = {}) => {
  const [stateMap, setStateMap] = (0, import_react2.useState)(/* @__PURE__ */ new Map());
  const latestStateMap = (0, import_react2.useRef)(stateMap);
  const configMap = (0, import_react2.useRef)(/* @__PURE__ */ new Map());
  const [enterTimeout, exitTimeout] = getTimeout(timeout);
  const setItem = (0, import_react2.useCallback)((key, config) => {
    const {
      initialEntered: _initialEntered = initialEntered
    } = config || {};
    const status = _initialEntered ? ENTERED : startOrEnd(mountOnEnter);
    updateState(key, status, setStateMap, latestStateMap);
    configMap.current.set(key, {});
  }, [initialEntered, mountOnEnter]);
  const deleteItem = (0, import_react2.useCallback)((key) => {
    const newStateMap = new Map(latestStateMap.current);
    if (newStateMap.delete(key)) {
      setStateMap(newStateMap);
      latestStateMap.current = newStateMap;
      configMap.current.delete(key);
      return true;
    }
    return false;
  }, []);
  const endTransition = (0, import_react2.useCallback)((key) => {
    const stateObj = latestStateMap.current.get(key);
    if (!stateObj) {
      console.error(`[React-Transition-State] invalid key: ${key}`);
      return;
    }
    const {
      timeoutId
    } = configMap.current.get(key);
    const status = getEndStatus(stateObj._s, unmountOnExit);
    status && updateState(key, status, setStateMap, latestStateMap, timeoutId, onChange);
  }, [onChange, unmountOnExit]);
  const toggle = (0, import_react2.useCallback)((key, toEnter) => {
    const stateObj = latestStateMap.current.get(key);
    if (!stateObj) {
      console.error(`[React-Transition-State] invalid key: ${key}`);
      return;
    }
    const config = configMap.current.get(key);
    const transitState = (status) => {
      updateState(key, status, setStateMap, latestStateMap, config.timeoutId, onChange);
      switch (status) {
        case ENTERING:
          if (enterTimeout >= 0)
            config.timeoutId = setTimeout(() => endTransition(key), enterTimeout);
          break;
        case EXITING:
          if (exitTimeout >= 0)
            config.timeoutId = setTimeout(() => endTransition(key), exitTimeout);
          break;
        case PRE_ENTER:
        case PRE_EXIT:
          config.timeoutId = nextTick(transitState, status);
          break;
      }
    };
    const enterStage = stateObj.isEnter;
    if (typeof toEnter !== "boolean")
      toEnter = !enterStage;
    if (toEnter) {
      if (!enterStage) {
        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);
        !allowMultiple && latestStateMap.current.forEach((_, _key) => _key !== key && toggle(_key, false));
      }
    } else {
      if (enterStage) {
        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));
      }
    }
  }, [onChange, endTransition, allowMultiple, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);
  const toggleAll = (0, import_react2.useCallback)((toEnter) => {
    if (!allowMultiple && toEnter !== false)
      return;
    for (const key of latestStateMap.current.keys())
      toggle(key, toEnter);
  }, [allowMultiple, toggle]);
  return {
    stateMap,
    toggle,
    toggleAll,
    endTransition,
    setItem,
    deleteItem
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionProvider.mjs
var getTransition = (transition, name) => transition === true || !!(transition && transition[name]);
var useAccordionProvider = ({
  transition,
  transitionTimeout,
  ...rest
} = {}) => {
  const transitionMap = useTransitionMap({
    timeout: transitionTimeout,
    enter: getTransition(transition, "enter"),
    exit: getTransition(transition, "exit"),
    preEnter: getTransition(transition, "preEnter"),
    preExit: getTransition(transition, "preExit"),
    ...rest
  });
  return {
    mountOnEnter: !!rest.mountOnEnter,
    initialEntered: !!rest.initialEntered,
    ...transitionMap
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/components/ControlledAccordion.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@szhsin/react-accordion/dist/esm/utils/constants.mjs
var import_react3 = __toESM(require_react(), 1);
var ACCORDION_BLOCK = "szh-accordion";
var ACCORDION_PREFIX = "szh-adn";
var ACCORDION_ATTR = `data-${ACCORDION_PREFIX}`;
var ACCORDION_BTN_ATTR = `data-${ACCORDION_PREFIX}-btn`;
var AccordionContext = (0, import_react3.createContext)({});

// node_modules/@szhsin/react-accordion/dist/esm/utils/bem.mjs
var bem = (block, element, modifiers) => (className, props) => {
  const blockElement = element ? `${block}__${element}` : block;
  let classString = blockElement;
  modifiers && Object.keys(modifiers).forEach((name) => {
    const value = modifiers[name];
    if (value)
      classString += ` ${blockElement}--${value === true ? name : `${name}-${value}`}`;
  });
  let expandedClassName = typeof className === "function" ? className(props) : className;
  if (typeof expandedClassName === "string") {
    expandedClassName = expandedClassName.trim();
    if (expandedClassName)
      classString += ` ${expandedClassName}`;
  }
  return classString;
};

// node_modules/@szhsin/react-accordion/dist/esm/utils/mergeProps.mjs
var mergeProps = (target, source) => {
  if (!source)
    return target;
  const result = {
    ...target
  };
  Object.keys(source).forEach((key) => {
    const targetProp = target[key];
    const sourceProp = source[key];
    if (typeof sourceProp === "function" && targetProp) {
      result[key] = (...e) => {
        targetProp(...e);
        sourceProp(...e);
      };
    } else {
      result[key] = sourceProp;
    }
  });
  return result;
};

// node_modules/@szhsin/react-accordion/dist/esm/components/AccordionProvider.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var AccordionProvider = (props) => (0, import_jsx_runtime.jsx)(AccordionContext.Provider, {
  ...props
});

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordion.mjs
var getAccordion = (node) => {
  do {
    node = node.parentElement;
  } while (node && !node.hasAttribute(ACCORDION_ATTR));
  return node;
};
var getNextIndex = (moveUp, current2, length) => moveUp ? current2 > 0 ? current2 - 1 : length - 1 : (current2 + 1) % length;
var moveFocus = (moveUp, e) => {
  const {
    activeElement
  } = document;
  if (!activeElement || !activeElement.hasAttribute(ACCORDION_BTN_ATTR) || getAccordion(activeElement) !== e.currentTarget)
    return;
  const nodes = e.currentTarget.querySelectorAll(`[${ACCORDION_BTN_ATTR}]`);
  const {
    length
  } = nodes;
  for (let i = 0; i < length; i++) {
    if (nodes[i] === activeElement) {
      let next = getNextIndex(moveUp, i, length);
      while (getAccordion(nodes[i]) !== getAccordion(nodes[next]))
        next = getNextIndex(moveUp, next, length);
      if (i !== next) {
        e.preventDefault();
        nodes[next].focus();
      }
      break;
    }
  }
};
var useAccordion = () => {
  const accordionProps = {
    [ACCORDION_ATTR]: "",
    onKeyDown: (e) => e.key === "ArrowUp" ? moveFocus(true, e) : e.key === "ArrowDown" && moveFocus(false, e)
  };
  return {
    accordionProps
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/components/ControlledAccordion.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ControlledAccordion = (0, import_react4.forwardRef)(({
  providerValue,
  className,
  ...rest
}, ref) => {
  const {
    accordionProps
  } = useAccordion();
  return (0, import_jsx_runtime2.jsx)(AccordionProvider, {
    value: providerValue,
    children: (0, import_jsx_runtime2.jsx)("div", {
      ...mergeProps(accordionProps, rest),
      ref,
      className: bem(ACCORDION_BLOCK)(className)
    })
  });
});
ControlledAccordion.displayName = "ControlledAccordion";

// node_modules/@szhsin/react-accordion/dist/esm/components/Accordion.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var Accordion = (0, import_react5.forwardRef)(({
  allowMultiple,
  initialEntered,
  mountOnEnter,
  unmountOnExit,
  transition,
  transitionTimeout,
  onStateChange,
  ...rest
}, ref) => {
  const providerValue = useAccordionProvider({
    allowMultiple,
    initialEntered,
    mountOnEnter,
    unmountOnExit,
    transition,
    transitionTimeout,
    onStateChange
  });
  return (0, import_jsx_runtime3.jsx)(ControlledAccordion, {
    ...rest,
    ref,
    providerValue
  });
});
Accordion.displayName = "Accordion";

// node_modules/@szhsin/react-accordion/dist/esm/components/AccordionItem.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useId.mjs
var import_react6 = __toESM(require_react(), 1);
var current = 0;
var useIdShim = () => {
  const [id, setId] = (0, import_react6.useState)();
  (0, import_react6.useEffect)(() => setId(++current), []);
  return id && `${ACCORDION_PREFIX}-${id}`;
};
var useId = import_react6.default.useId || useIdShim;

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionItem.mjs
var useAccordionItem = ({
  state,
  toggle,
  disabled
}) => {
  const buttonId = useId();
  const panelId = buttonId && buttonId + "-";
  const buttonProps = {
    id: buttonId,
    "aria-controls": panelId,
    "aria-expanded": state.isEnter,
    onClick: toggle
  };
  disabled ? buttonProps.disabled = true : buttonProps[ACCORDION_BTN_ATTR] = "";
  const panelProps = {
    id: panelId,
    "aria-labelledby": buttonId,
    role: "region"
  };
  return {
    buttonProps,
    panelProps
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useHeightTransition.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@szhsin/react-accordion/dist/esm/utils/useIsomorphicLayoutEffect.mjs
var import_react7 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useHeightTransition.mjs
var useHeightTransition = ({
  status,
  isResolved
}) => {
  const [height, setHeight] = (0, import_react8.useState)();
  const elementRef = (0, import_react8.useRef)(null);
  useIsomorphicLayoutEffect(() => {
    (status === "preEnter" || status === "preExit") && setHeight(elementRef.current.getBoundingClientRect().height);
  }, [status]);
  const style = {
    height: status === "preEnter" || status === "exiting" ? 0 : status === "entering" || status === "preExit" ? height : void 0,
    overflow: isResolved ? void 0 : "hidden"
  };
  return [style, elementRef];
};

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useMergeRef.mjs
var import_react9 = __toESM(require_react(), 1);
function setRef(ref, instance) {
  typeof ref === "function" ? ref(instance) : ref.current = instance;
}
function useMergeRef(refA, refB) {
  return (0, import_react9.useMemo)(() => {
    if (!refA)
      return refB;
    if (!refB)
      return refA;
    return (instance) => {
      setRef(refA, instance);
      setRef(refB, instance);
    };
  }, [refA, refB]);
}

// node_modules/@szhsin/react-accordion/dist/esm/components/withAccordionItem.mjs
var import_react12 = __toESM(require_react(), 1);

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionItemEffect.mjs
var import_react11 = __toESM(require_react(), 1);

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionContext.mjs
var import_react10 = __toESM(require_react(), 1);
var getItemState = (providerValue, key, itemInitialEntered) => {
  const {
    stateMap,
    mountOnEnter,
    initialEntered
  } = providerValue;
  const _initialEntered = itemInitialEntered != null ? itemInitialEntered : initialEntered;
  return stateMap.get(key) || {
    status: _initialEntered ? "entered" : mountOnEnter ? "unmounted" : "exited",
    isMounted: !mountOnEnter,
    isEnter: _initialEntered,
    isResolved: true
  };
};
var useAccordionContext = () => {
  const context = (0, import_react10.useContext)(AccordionContext);
  if (!context.stateMap) {
    throw new Error("[React-Accordion] Cannot find a <AccordionProvider/> above this AccordionItem.");
  }
  return context;
};

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionItemEffect.mjs
var useAccordionItemEffect = ({
  itemKey,
  initialEntered,
  disabled
} = {}) => {
  const itemRef = (0, import_react11.useRef)(null);
  const context = useAccordionContext();
  const key = itemKey != null ? itemKey : itemRef.current;
  const state = getItemState(context, key, initialEntered);
  const {
    setItem,
    deleteItem,
    toggle
  } = context;
  (0, import_react11.useEffect)(() => {
    if (disabled)
      return;
    const key2 = itemKey != null ? itemKey : itemRef.current;
    setItem(key2, {
      initialEntered
    });
    return () => void deleteItem(key2);
  }, [setItem, deleteItem, itemKey, initialEntered, disabled]);
  return {
    itemRef,
    state,
    toggle: (0, import_react11.useCallback)((toEnter) => toggle(key, toEnter), [toggle, key])
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/components/withAccordionItem.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var withAccordionItem = (WrappedItem2) => {
  const WithAccordionItem = (0, import_react12.forwardRef)(({
    itemKey,
    initialEntered,
    ...rest
  }, ref) => (0, import_jsx_runtime4.jsx)(WrappedItem2, {
    forwardedRef: ref,
    ...rest,
    ...useAccordionItemEffect({
      itemKey,
      initialEntered,
      disabled: rest.disabled
    })
  }));
  WithAccordionItem.displayName = "WithAccordionItem";
  return WithAccordionItem;
};

// node_modules/@szhsin/react-accordion/dist/esm/components/AccordionItem.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var getRenderNode = (nodeOrFunc, props) => typeof nodeOrFunc === "function" ? nodeOrFunc(props) : nodeOrFunc;
var WrappedItem = (0, import_react13.memo)(({
  forwardedRef,
  itemRef,
  state,
  toggle,
  className,
  disabled,
  header,
  headingTag: Heading = "h3",
  headingProps,
  buttonProps,
  contentProps,
  panelProps,
  children,
  ...rest
}) => {
  const itemState = {
    state,
    toggle,
    disabled
  };
  const {
    buttonProps: _buttonProps,
    panelProps: _panelProps
  } = useAccordionItem(itemState);
  const [transitionStyle, _panelRef] = useHeightTransition(state);
  const panelRef = useMergeRef(panelProps == null ? void 0 : panelProps.ref, _panelRef);
  const {
    status,
    isMounted,
    isEnter
  } = state;
  return (0, import_jsx_runtime5.jsxs)("div", {
    ...rest,
    ref: useMergeRef(forwardedRef, itemRef),
    className: bem(ACCORDION_BLOCK, "item", {
      status,
      expanded: isEnter
    })(className, state),
    children: [(0, import_jsx_runtime5.jsx)(Heading, {
      ...headingProps,
      style: {
        margin: 0,
        ...headingProps == null ? void 0 : headingProps.style
      },
      className: bem(ACCORDION_BLOCK, "item-heading")(headingProps == null ? void 0 : headingProps.className, state),
      children: (0, import_jsx_runtime5.jsx)("button", {
        ...mergeProps(_buttonProps, buttonProps),
        type: "button",
        className: bem(ACCORDION_BLOCK, "item-btn")(buttonProps == null ? void 0 : buttonProps.className, state),
        children: getRenderNode(header, itemState)
      })
    }), isMounted && (0, import_jsx_runtime5.jsx)("div", {
      ...contentProps,
      style: {
        display: status === "exited" ? "none" : void 0,
        ...transitionStyle,
        ...contentProps == null ? void 0 : contentProps.style
      },
      className: bem(ACCORDION_BLOCK, "item-content")(contentProps == null ? void 0 : contentProps.className, state),
      children: (0, import_jsx_runtime5.jsx)("div", {
        ...mergeProps(_panelProps, panelProps),
        ref: panelRef,
        className: bem(ACCORDION_BLOCK, "item-panel")(panelProps == null ? void 0 : panelProps.className, state),
        children: getRenderNode(children, itemState)
      })
    })]
  });
});
WrappedItem.displayName = "AccordionItem";
var AccordionItem = withAccordionItem(WrappedItem);

// node_modules/@szhsin/react-accordion/dist/esm/hooks/useAccordionState.mjs
var useAccordionState = () => {
  const context = useAccordionContext();
  return {
    getItemState: (key, {
      initialEntered
    } = {}) => getItemState(context, key, initialEntered),
    toggle: context.toggle,
    toggleAll: context.toggleAll
  };
};

// node_modules/@szhsin/react-accordion/dist/esm/index.mjs
"use client";
export {
  Accordion,
  AccordionItem,
  AccordionProvider,
  ControlledAccordion,
  useAccordion,
  useAccordionItem,
  useAccordionItemEffect,
  useAccordionProvider,
  useAccordionState,
  useHeightTransition,
  useMergeRef,
  withAccordionItem
};
//# sourceMappingURL=@szhsin_react-accordion.js.map
